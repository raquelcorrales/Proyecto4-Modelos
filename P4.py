#!/usr/bin/env python
# coding: utf-8

# ---
# 
# ## Universidad de Costa Rica
# ### Escuela de Ingenier칤a El칠ctrica
# #### IE0405 - Modelos Probabil칤sticos de Se침ales y Sistemas
# 
# ---
# 
# * Estudiante: **Raquel Sof칤a Corrales Mar칤n /Mariana Chung Garita/ Josu칠 Abarca L칩pez**
# * Carn칠: **B92378 /B92250/ B80016**
# * Grupo: **1/1**
# 
# ---
# # `P4` - *Modulaci칩n digital IQ*
# 
# > La modulaci칩n digital es una de las aplicaciones del an치lisis de procesos estoc치sticos, y es parte de los sistemas digitales de comunicaci칩n. Este proyecto presenta una introduci칩n a t칩picos fundamentales de la ingenier칤a de comunicaciones para simular un sistema de transmisi칩n de im치genes de baja resoluci칩n.
# 
# ---
# * Elaboraci칩n de nota te칩rica y demostraci칩n: **Jeaustin Sirias Chac칩n**, como parte de IE0499 - Proyecto El칠ctrico: *Estudio y simulaci칩n de aplicaciones de la teor칤a de probabilidad en la ingenier칤a el칠ctrica*.
# * Revisi칩n y edici칩n: **Fabi치n Abarca Calder칩n**

# <span id="Chapter1"></span>
# 
# ## 1. - Una introducci칩n a los sistemas de comunicaciones
# 
# La ingenier칤a de comunicaciones es la rama de la ciencia y la tecnolog칤a que busca establecer sistemas de transmisi칩n de informaci칩n entre emisores y receptores separados espacial o temporalmente. 
# 
# El modelo m치s generalizado de un sistema de comunicaciones incluye una fuente de informaci칩n, un transmisor que codifica la informaci칩n, un esquema de modulaci칩n que adapta la se침al al medio, un canal de transmisi칩n, un receptor que decodifica la informaci칩n y un destino. El siguiente es un ejemplo de env칤o de im치genes: 
# 
# <img align='center' src='https://i.imgur.com/ZqQ9Psh.png' width ='450'/>
# 
# Un sistema de comunicaciones completo implica etapas altamente complejas y detalladas, tales como la multiplexaci칩n de m칰ltiples usuarios, compresi칩n de la informaci칩n, as칤 como correcci칩n de datos err칩neos. En esta actividad se estudiar치 solamente **los esquemas de modulaci칩n digital y el canal ruidoso**, que corresponde a dos de las etapas m치s relevantes.

# ### 1.1. - La modulaci칩n digital
# 
# Sup칩ngase, por ejemplo, la tramisi칩n inal치mbrica de una imagen a largas distancias, 쯖칩mo es posible enviar sus pixeles (que se asumen como "algo digital") de un punto a otro, a trav칠s de un medio f칤sico que es esencialmente "anal칩gico"?
# 
# La *modulaci칩n* en ingenier칤a de comunicaciones consiste en depositar la informaci칩n de una **se침al moduladora** (fuente de informaci칩n) en una **se침al portadora** que est치 dise침ada para el medio f칤sico de transmisi칩n. En el caso espec칤fico de la modulaci칩n *digital*, la fuente de informaci칩n es, precisamente, *digital* (discreta en el tiempo y la amplitud).
# 
# <img align='center' src='https://i.imgur.com/eVnhbbG.png' width ='400'/>
# 
# La modulaci칩n sirve dos prop칩sitos importantes:
# 
# * La se침al portadora est치 **adaptada al medio** por el que se va a transmitir o a las tecnolog칤as que se utilizan para ello. Por ejemplo: una se침al de audio, en sus frecuencias originales, no puede ser transmitida eficientemente con antenas peque침as y portables. Otro ejemplo: las se침ales digitales cuadradas (transiciones entre 0 y 1) sufrir칤an graves distorsiones y atenuaci칩n si se transmiten tal cual a grandes distancias por un conductor el칠ctrico.
# * Como la se침al portadora puede modificarse a conveniencia, es posible crear esquemas de **acceso al medio** para m칰ltiples usuarios. Por ejemplo: la modulaci칩n FM (*frequency modulation*) utiliza distintas franjas del espectro radioel칠ctrico para acomodar distintas emisiones ("radioemisoras").
# 
# La modulaci칩n digital presenta ventajas adicionales:
# 
# * Un esquema de modulaci칩n con t칠cnicas de codificaci칩n apropiadas es capaz de reconstruir se침ales distorsionadas.
# * El flujo de informaci칩n (bits por unidad de tiempo) es adaptativo, seg칰n las condiciones del canal.

# ### 1.2. - La demodulaci칩n
# 
# Si una se침al ha atravesado un canal f칤sico y se encuentra en el receptor: *쯖칩mo pueden los bits ser reconstruidos nuevamente a partir de la se침al modulada $s(t)$ que fue recibida?*, *쯤u칠 ocurrir치 si esta se침al fue distorsionada por cierto ruido durante su traves칤a por el medio de transmisi칩n?* Estas son preguntas claves para el dise침o de sistema de comunicaci칩n.
# 
# Algunas de las t칠cnicas de procesamiento de se침ales para extraer la informaci칩n de la se침al son:
# 
# * Demodulaci칩n por **detecci칩n de envolvente**
# * Demodulaci칩n por **detecci칩n de energ칤a**
# * Demodulaci칩n por **m칤nima distancia euclidiana**
# * Demodulaci칩n por **detecci칩n de lazo de seguimiento de fase**
# * Demodulaci칩n por **detecci칩n de fuerza en recepci칩n**
# 
# ### 1.3. - Sobre canales ruidosos
# 
# > El ruido en un medio de transmisi칩n generalmente se debe a variables f칤sicas de comportamiento aleatorio. Por ejemplo: los fen칩menos atmosf칠ricos, las vibraciones, la interferencia entre se침ales y la temperatura.
# 
# En particular, los sistemas el칠ctricos y electr칩nicos son com칰nmente afectados por el denominado **ruido aditivo blanco gaussiano** (AWGN, por las siglas en ingl칠s de *Additive White Gaussian Noise*).
# 
# * Es **aditivo** porque la perturbaci칩n se "adhiere" o se "suma" a la se침al viajera $s(t)$ al atravesar un determinado canal. De forma gen칠rica, la se침al resultante es la original m치s ruido, es decir, $\hat{s}(t) = s(t) + n(t)$.
# * Es **blanco** porque tiene una [densidad espectral de potencia](https://es.wikipedia.org/wiki/Densidad_espectral) aproximadamente constante dentro del ancho de banda de inter칠s, es decir, est치 presente en todos los componentes de frecuencia. 쯇or qu칠 entonces "blanco"?, podr칤an preguntarse ustedes.
# * Es **gaussiano** porque la funci칩n de densidad probabil칤stica (PDF) de la **amplitud** del ruido es precisamente una distribuci칩n normal, con par치metros tales que la media es t칤picamente cero (lo que implica que tiene valores positivos y negativos) y la varianza tiene un valor relacionado con la potencia del ruido.
# 
# <img align='center' src='https://i.imgur.com/gtiM5SJ.png' width='850'/>

# ### 1.4 -  La relaci칩n se침al-a-ruido
# 
# La relaci칩n se침al-a-ruido (**SNR**, *Signal-to-Noise Ratio*) es una medida de la proporci칩n entre la potencia $P_s$ de una se침al $s(t)$ y la potencia $P_n$ del ruido $n(t)$ que la corrompe. Su magnitud suele ser especificada en decibel (dB). Un SNR alto indica que la presencia de una se침al es m치s fuerte que la presencia del ruido, mientras que un SNR bajo indica lo contrario. Por ejemplo: el audio de un disco de vinilo tiene un SNR de unos 60 dB mientras que un disco compacto tiene 90 dB.
# 
# Su relaci칩n se expresa de la siguiente manera:
# 
# $$
# \mathrm{SNR}_{\mathrm{dB}} = 10\log(\mathrm{SNR}) = 10\log\left ( \frac{P_s}{P_n} \right )
# $$
# 
# Dado lo anterior, 60 dB implica una se침al un mill칩n de veces m치s potente que el ruido, y 90 dB mil millones de veces m치s grande. Hay que notar en el caso del audio que la percepci칩n humana de la audici칩n no es lineal, y por eso se prefiere una medida logar칤tmica como el dB.
# 
# ### 1.5 - Tasa de error binario
# 
# La tasa de error de bit (**BER**, *Bit Error Rate*) es una medida del error $p(\epsilon)$ que contiene un medio de transmisi칩n no ideal (ruidoso). Seg칰n la definici칩n estad칤stica de la probabilidad, la probabilidad de ocurrencia de un suceso es la raz칩n de los casos favorables entre los casos posibles:
# 
# $$
# \displaystyle
# p(\epsilon) = \frac{\text{bits fallidos}}{\text{bit totales}}
# $$
# 
# En sistemas de comunicaciones usuales, las tasas de error aceptables son de $10^{-5}$ o menores (un error por cada cien mil bits).

# ---
# ## 2. - Conceptos b치sicos del procesamiento de im치genes
# 
# 
# ### 2.1 - Los p칤xeles
# 
# Una imagen digital es un conjunto de pixeles (unidad m칤nima de color) en un plano. La sinergia de sus colores permite visualizar una imagen con sentido para el ojo humano.
# 
# <img align='center' src='https://i.imgur.com/ohBErgV.jpg' width='350'/>
# 
# ### 2.2 - El modelo de colores *RGB*
# 
# El modelo RGB (por las siglas en ingl칠s de *Red, Green, Blue*) es el esquema de colores digitales m치s tradicional. Es "aditivo" en el sentido de que los colores se forman por la combinaci칩n de los componentes R, G, y B. Algunos ejemplos son: 
# 
# | Color             |                       Tripleta RGB                         | 
# |-----------------------|----------------------------------------------------------------|
# | <img src="https://i.pinimg.com/564x/2c/c6/2e/2cc62efc5998bc3bfdec089acf1e12c4.jpg" width="30"></img>                  |          `(255, 0, 0)`         |
# | <img src="https://i.pinimg.com/564x/ad/2f/b5/ad2fb5dd9b658483cb5c4f6120fe528b.jpg" width="30"></img> |          `(0, 0, 255)`         |
# | <img src="https://i.pinimg.com/564x/26/8b/2c/268b2c4f2742bfdc73dfbc8154ef5d11.jpg" width="30"></img> |          `(0, 0, 255)`         |
# | <img src="https://i.pinimg.com/564x/e5/be/78/e5be78c8312fd6ce650408abb87bd0ce.jpg" width="30"></img>                  |          `(0, 0, 0)`         |
# | <img src="https://i.pinimg.com/564x/a2/73/09/a27309683bfcaaf152864a0e19e79fd9.jpg" width="30"></img>                  |          `(0, 0, 128)`         |
# 
# A cada color se le denomina **canal**, de forma que un pixel RGB tiene tres canales. El modelo RGB es un esquema de colores discreto: cada canal tiene un rango de libertad entre 0 y 255, es decir, 256 tonos posibles por canal. La cantidad de memoria necesaria para almacenar un canal es de 8 bits, lo que significa que un pixel RGB tiene 8 $\times$ 3 = 24 bits. De aqu칤 viene el comentario "*este televisor tiene 16 millones de colores, las im치genes se ver치n buen칤simas*", un n칰mero obtenido por la regla de la multiplicaci칩n:
# 
# $$
# 256 \times 256 \times 256 = 2^{24} = 16\,777\,216 \,\text{combinaciones de colores}
# $$
# 
# ### 2.3 - El formato de compresi칩n de im치genes *JPG*
# 
# Las im치genes digitales con formato JPG poseen un modelo de colores **RGB** y se trata de un "formato con compresi칩n", en el que la imagen ha sido sometida a un proceso de reducci칩n de informaci칩n redundante para "aligerar" su peso en memoria.
# 
# Por ejemplo, la imagen mostrada anteriormente es de 198 $\times$ 89 pixeles, lo que implicar칤a un tama침o total de 198 $\times$ 89 $\times$ 24 bit / 8 = 52,87 kB, sin embargo el tama침o del archivo de la compresi칩n es de solamente 8,58 kB. El nivel de compresi칩n depende de cada imagen, pero alcanza t칤picamente la relaci칩n 10:1.

# ---
# 
# ## 3. - Simulando un sistema de comunicaciones 
# 
# Para utilizar los conocimientos adquiridos, se proceder치 a simular un **sistema de comunicaciones para la transmisi칩n de im치genes de baja resoluci칩n**. 
# 
# El objetivo es transmitir la siguiente imagen (o cualquiera de baja resoluci칩n de su elecci칩n):
# 
# <img align='center' src='https://i.imgur.com/ohBErgV.jpg' width='250'/>
# 
# Las condiciones iniciales para el sistema de comunicaciones ser치n las siguientes:
# 
# * Una onda portadora banda base con **frecuencia $f_s$ = 5 kHz.**
# * Una frecuencia de muestreo de **20 muestras por per칤odo**.
# * Una relaci칩n se침al/ruido de **5 dB**.
# 
# ### 3.1. - Funciones implementadas
# 
# A continuaci칩n se especificar치n las funciones desarrolladas en la simulaci칩n del sistema (considerar que en telecomunicaciones se utiliza **Tx** para referirse a transmisi칩n y **Rx** a recepci칩n):
# 
# 1. `fuente_info(imagen)`: Extrae en un `array` de NumPy los pixeles contenidos en la imagen.
# * `rgb_a_bit(vector_pixel)`: Convierte los pixeles del 'array' de NumPy en una cadena `bits_Tx` continua de tama침o $(1 \times k)$, en donde $k$ es la cantidad total de bits de la imagen.
# * `modulador(bits_Rx, FS, MPP)`: Convierte la se침al de informaci칩n (arreglo de `bits_Tx`) en una se침al modulada bajo un esquema **BPSK**.
# * `canal_ruidoso(senal_Tx, Pm, SNR)`: Simula un canala ruidoso con **AWGN** para `senal_Tx`.
# * `demodulador(senal_Rx, carrier, MPP)`: Demodula a `senal_Rx` (se침al recibida) y determina los bits recibidos usando el criterio de demodulaci칩n por detecci칩n de energ칤a.
# * `bits_a_rgb(bits_Rx, dims)`: Reconstruye los bits recibidos en `bits_Rx` en una imagen.
# 
# Las bibliotecas de Python de inter칠s para este proyecto son:
# 
# ```python
# # Para manipular im치genes (Python Imaging Library)
# from PIL import Image
# 
# # Para manipular 'arrays' de pixeles y bits, se침ales y operaciones
# import numpy as np
# 
# # Para visualizar im치genes y se침ales
# import matplotlib.pyplot as plt
# 
# # Para medir el tiempo de simulaci칩n
# import time
# ```

# #### 3.1.1 - Extracci칩n de los pixeles de una imagen (fuente de informaci칩n)

# In[1]:


from PIL import Image
import numpy as np

def fuente_info(imagen):
    '''Una funci칩n que simula una fuente de
    informaci칩n al importar una imagen y 
    retornar un vector de NumPy con las 
    dimensiones de la imagen, incluidos los
    canales RGB: alto x largo x 3 canales

    :param imagen: Una imagen en formato JPG
    :return: un vector de pixeles
    '''
    img = Image.open(imagen)
    
    return np.array(img)


# Es relevante considerar la forma de la salida de la funci칩n anterior.
# 
# ```python
# >>> pixeles = fuente_info('imagen.jpg')
# >>> print('Dimensiones: ', pixeles.shape, '\n')
# >>> print(pixeles)
# 
# Dimensiones: (300, 300, 3)
#     
# [[[132 123 118]
#   [133 124 119]
#   [136 127 122]
#   ...
#   [  8   2   2]
#   [ 10   1   4]
#   [ 10   1   2]]
# 
#  [[143 134 129]
#   [145 136 131]
#   [144 135 130]
#   ...
#   [ 13   3   1]
#   [ 15   5   3]
#   [ 15   7   5]]]
# ```
# 
# * Las dimensiones de la imagen elegida son (300, 300, 3); esto es su resoluci칩n: 300 px $\times$ 300 px. 
# * La tercera entrada del vector de dimensiones se refiere a las tres "capas" o canales R, G y B que componen aditivamente cada uno de los pixeles de esta imagen. 
# * En este caso espec칤fico hay $300 \times 300 = 90\,000$ pixeles por canal. 
# * 쯇uede estimarse cu치ntos bits tiene la imagen? Puesto que un solo canal tiene 8 bits de profundidad (256 niveles) por pixel, entonces la imagen en transmisi칩n tiene, *antes de la compresi칩n*:
# 
# $$
# 90\,000 \times 8 \times 3 = 2\,160\,000 \,\text{bit}
# $$

# #### 3.1.2. - Codificaci칩n de pixeles a una base binaria (bits)

# In[2]:


import numpy as np

def rgb_a_bit(array_imagen):
    '''Convierte los pixeles de base 
    decimal (de 0 a 255) a binaria 
    (de 00000000 a 11111111).

    :param imagen: array de una imagen 
    :return: Un vector de (1 x k) bits 'int'
    '''
    # Obtener las dimensiones de la imagen
    x, y, z = array_imagen.shape
    
    # N칰mero total de elementos (pixeles x canales)
    n_elementos = x * y * z

    # Convertir la imagen a un vector unidimensional de n_elementos
    pixeles = np.reshape(array_imagen, n_elementos)

    # Convertir los canales a base 2
    bits = [format(pixel, '08b') for pixel in pixeles]
    bits_Rx = np.array(list(''.join(bits)))
    
    return bits_Rx.astype(int)


# #### 3.1.3. - Esquema de modulaci칩n BPSK
# 
# El esquema de modulaci칩n o "codificaci칩n" por desplazamiento de fase o [PSK](https://es.wikipedia.org/wiki/Modulaci%C3%B3n_por_desplazamiento_de_fase) (de *phase shift keying*) consiste, como lo sugiere su nombre, en **variar la fase** de la onda portadora $c(t)$ a partir grupos de bits codificados en s칤mbolos discretos. El caso **BPSK** hace referencia a la modulaci칩n bi-fase, con dos s칤mbolos disponibles. En general hay $M = 2^k$ s칤mbolos, con $k$ la cantidad de bits para representarlos. Por tanto, con BPSK y despejando para $k$ con $M = 2$:
# 
# $$
# \log_2(2) = 1 \quad \text{bit/s칤mbolo}
# $$
# 
# Puede haber un `0` o un `1` por cada s칤mbolo. Puesto que el esquema se basa en el desplazamiento de fase entonces es conveniente asignar valores angulares de fase en radianes, como 0 y $\pi$:
# 
# $$
# s(t) = A_c \cdot \sin(2\pi f_c t - \theta_c), \quad \text{con}\, \theta_c \in \{0, \pi\}
# $$
# 
# Por la identidad trigonom칠trica $\sin(\alpha - \pi) = \sin(-\alpha) = -\sin(\alpha)$, impl칤citamente $s(t)$ puede manipular su desplazamiento de fase desde la 칩ptica de la amplitud $A_c$:
# 
# $$
# A_c= 
# \begin{cases}
#              1, &   \text{si} \quad \theta_c = 0 \\
#              -1, &  \text{si} \quad \theta_c = \pi \\
# \end{cases}
# $$
# 
# A trav칠s de este "artificio" la modulaci칩n **BPSK** (pero solo BPSK) pasa de ser un asunto de fases a un tema de amplitud. Esto simplifica en gran medida la programaci칩n del esquema, puesto que si el bit entrante es cero, entonces la fase de la portadora se invierte con solo tomar $A_c = -1$. En el caso contrario (si el bit entrante es un uno), entonces $A_c = 1$ y ya no es necesario lidiar con las fases en t칠rminos del 치ngulo $\theta_c$. A continuaci칩n se muestra una implementaci칩n de esta modulaci칩n.

# In[3]:


import numpy as np

def modulador(bits, fc, mpp):
    '''Un m칠todo que simula el esquema de 
    modulaci칩n digital BPSK.

    :param bits: Vector unidimensional de bits
    :param fc: Frecuencia de la portadora en Hz
    :param mpp: Cantidad de muestras por periodo de onda portadora
    :return: Un vector con la se침al modulada
    :return: Un valor con la potencia promedio [W]
    :return: La onda portadora c(t)
    :return: La onda cuadrada moduladora (informaci칩n)
    '''
    # 1. Par치metros de la 'se침al' de informaci칩n (bits)
    N = len(bits) # Cantidad de bits

    # 2. Construyendo un periodo de la se침al portadora c(t)
    Tc = 1 / fc  # periodo [s]
    t_periodo = np.linspace(0, Tc, mpp)  # mpp: muestras por per칤odo
    portadora = np.sin(2*np.pi*fc*t_periodo)

    # 3. Inicializar la se침al modulada s(t)
    t_simulacion = np.linspace(0, N*Tc, N*mpp) 
    senal_Tx = np.zeros(t_simulacion.shape)
    moduladora = np.zeros(t_simulacion.shape)  # (opcional) se침al de bits
 
    # 4. Asignar las formas de onda seg칰n los bits (BPSK)
    for i, bit in enumerate(bits):
        if bit == 1:
            senal_Tx[i*mpp : (i+1)*mpp] = portadora
            moduladora[i*mpp : (i+1)*mpp] = 1
        else:
            senal_Tx[i*mpp : (i+1)*mpp] = portadora * -1
            moduladora[i*mpp : (i+1)*mpp] = 0
    
    # 5. Calcular la potencia promedio de la se침al modulada
    P_senal_Tx = (1 / (N*Tc)) * np.trapz(pow(senal_Tx, 2), t_simulacion)
    
    return senal_Tx, P_senal_Tx, portadora, moduladora  


# #### 3.1.4. - Construcci칩n de un canal con ruido AWGN

# In[3]:


import numpy as np

def canal_ruidoso(senal_Tx, Pm, SNR):
    '''Un bloque que simula un medio de trans-
    misi칩n no ideal (ruidoso) empleando ruido
    AWGN. Pide por par치metro un vector con la
    se침al provieniente de un modulador y un
    valor en decibelios para la relaci칩n se침al
    a ruido.

    :param senal_Tx: El vector del modulador
    :param Pm: Potencia de la se침al modulada
    :param SNR: Relaci칩n se침al-a-ruido en dB
    :return: La se침al modulada al dejar el canal
    '''
    # Potencia del ruido generado por el canal
    Pn = Pm / pow(10, SNR/10)

    # Generando ruido auditivo blanco gaussiano (potencia = varianza)
    ruido = np.random.normal(0, np.sqrt(Pn), senal_Tx.shape)

    # Se침al distorsionada por el canal ruidoso
    senal_Rx = senal_Tx + ruido

    return senal_Rx


# #### 3.1.5. - Esquema de demodulaci칩n

# In[5]:


import numpy as np

def demodulador(senal_Rx, portadora, mpp):
    '''Un m칠todo que simula un bloque demodulador
    de se침ales, bajo un esquema BPSK. El criterio
    de demodulaci칩n se basa en decodificaci칩n por 
    detecci칩n de energ칤a.

    :param senal_Rx: La se침al recibida del canal
    :param portadora: La onda portadora c(t)
    :param mpp: N칰mero de muestras por periodo
    :return: Los bits de la se침al demodulada
    '''
    # Cantidad de muestras en senal_Rx
    M = len(senal_Rx)

    # Cantidad de bits (s칤mbolos) en transmisi칩n
    N = int(M / mpp)

    # Vector para bits obtenidos por la demodulaci칩n
    bits_Rx = np.zeros(N)

    # Vector para la se침al demodulada
    senal_demodulada = np.zeros(senal_Rx.shape)

    # Pseudo-energ칤a de un per칤odo de la portadora
    Es = np.sum(portadora * portadora)

    # Demodulaci칩n
    for i in range(N):
        # Producto interno de dos funciones
        producto = senal_Rx[i*mpp : (i+1)*mpp] * portadora
        Ep = np.sum(producto) 
        senal_demodulada[i*mpp : (i+1)*mpp] = producto

        # Criterio de decisi칩n por detecci칩n de energ칤a
        if Ep > 0:
            bits_Rx[i] = 1
        else:
            bits_Rx[i] = 0

    return bits_Rx.astype(int), senal_demodulada


# #### 3.1.6. - Reconstrucci칩n de la imagen

# In[4]:


import numpy as np

def bits_a_rgb(bits_Rx, dimensiones):
    '''Un blque que decodifica el los bits
    recuperados en el proceso de demodulaci칩n

    :param: Un vector de bits 1 x k 
    :param dimensiones: Tupla con dimensiones de la img.
    :return: Un array con los pixeles reconstruidos
    '''
    # Cantidad de bits
    N = len(bits_Rx)

    # Se reconstruyen los canales RGB
    bits = np.split(bits_Rx, N / 8)

    # Se decofican los canales:
    canales = [int(''.join(map(str, canal)), 2) for canal in bits]
    pixeles = np.reshape(canales, dimensiones)

    return pixeles.astype(np.uint8)


# ### 3.2. - Simulaci칩n del sistema de comunicaciones con modulaci칩n BPSK
# 
# **Nota**: esta simulaci칩n tarda un poco y quiz치 hay que hacerla dos veces.

# In[7]:


import numpy as np
import matplotlib.pyplot as plt
import time

# Par치metros
fc = 5000  # frecuencia de la portadora
mpp = 20   # muestras por periodo de la portadora
SNR = -5   # relaci칩n se침al-a-ruido del canal

# Iniciar medici칩n del tiempo de simulaci칩n
inicio = time.time()

# 1. Importar y convertir la imagen a trasmitir
imagen_Tx = fuente_info('arenal.jpg')
dimensiones = imagen_Tx.shape

# 2. Codificar los pixeles de la imagen
bits_Tx = rgb_a_bit(imagen_Tx)

# 3. Modular la cadena de bits usando el esquema BPSK
senal_Tx, Pm, portadora, moduladora = modulador(bits_Tx, fc, mpp)

# 4. Se transmite la se침al modulada, por un canal ruidoso
senal_Rx = canal_ruidoso(senal_Tx, Pm, SNR)

# 5. Se desmodula la se침al recibida del canal
bits_Rx, senal_demodulada = demodulador(senal_Rx, portadora, mpp)

# 6. Se visualiza la imagen recibida 
imagen_Rx = bits_a_rgb(bits_Rx, dimensiones)
Fig = plt.figure(figsize=(10,6))

# C치lculo del tiempo de simulaci칩n
print('Duraci칩n de la simulaci칩n: ', time.time() - inicio)

# 7. Calcular n칰mero de errores
errores = sum(abs(bits_Tx - bits_Rx))
BER = errores/len(bits_Tx)
print('{} errores, para un BER de {:0.4f}.'.format(errores, BER))

# Mostrar imagen transmitida
ax = Fig.add_subplot(1, 2, 1)
imgplot = plt.imshow(imagen_Tx)
ax.set_title('Transmitido')

# Mostrar imagen recuperada
ax = Fig.add_subplot(1, 2, 2)
imgplot = plt.imshow(imagen_Rx)
ax.set_title('Recuperado')
Fig.tight_layout()

plt.imshow(imagen_Rx)


# In[8]:


import matplotlib.pyplot as plt

# Visualizar el cambio entre las se침ales
fig, (ax1, ax2, ax3, ax4) = plt.subplots(nrows=4, sharex=True, figsize=(14, 7))

# La onda cuadrada moduladora (bits de entrada)
ax1.plot(moduladora[0:600], color='r', lw=2) 
ax1.set_ylabel('$b(t)$')

# La se침al modulada por BPSK
ax2.plot(senal_Tx[0:600], color='g', lw=2) 
ax2.set_ylabel('$s(t)$')

# La se침al modulada al dejar el canal
ax3.plot(senal_Rx[0:600], color='b', lw=2) 
ax3.set_ylabel('$s(t) + n(t)$')

# La se침al demodulada
ax4.plot(senal_demodulada[0:600], color='m', lw=2) 
ax4.set_ylabel('$b^{\prime}(t)$')
ax4.set_xlabel('$t$ / milisegundos')
fig.tight_layout()
plt.show()


# ### 3.3. - Modulaci칩n IQ
# 
# Obs칠rvese que en la modulaci칩n BPSK anterior existe una 칰nica portadora (*carrier*) sinusoidal, dada por
# 
# $$
# c(t) = A_c \sin(2\pi f_c t - \theta_c)
# $$
# 
# La propiedad de la **ortogonalidad** entre las funciones $\sin(\omega t)$ y $\cos(\omega t)$ permite utilizar dos portadoras en lugar de una, de forma tal que es posible crear una se침al modulada del tipo:
# 
# $$
# s(t) = A_1 \cos(2\pi f_c t) + A_2 \sin(2\pi f_c t)
# $$
# 
# Esta se침al ocupa el mismo ancho de banda que una sola portadora sinusoidal, pero puede transportar el doble de la informaci칩n, codificada en $A_1$ y $A_2$. Debido a que las ondas seno y coseno est치n separadas por un desfase de 90 grados, a este tipo de modulaci칩n se le llama "en fase" (**I**, *in phase*) y "en cuadratura" (**Q**, *quadrature*), o **modulaci칩n IQ**.
# 
# #### 3.3.1. - Ortogonalidad
# 
# La prueba de ortogonalidad de dos funciones del tiempo est치 dada por el producto interno:
# 
# $$
# \begin{aligned}
# (f * g) (t) & = \langle f(t), g(t)\rangle \\
# & = \int f(t) g(t) \, \mathrm{d}t            
# \end{aligned}
# $$
# 
# Y en el caso de las dos portadoras sinusoidales:
# 
# $$
# \begin{aligned}
# (f * g) (t) & = \langle f(t), g(t)\rangle \\
# & = \int f(t) g(t) \, \mathrm{d}t \\
# & = \int \cos(2\pi f_c t) \, \sin(2\pi f_c t) \, \mathrm{d}t \\
# & = 0 
# \end{aligned}
# $$
# 
# > Podr칤a decirse, coloquialmente, que las portadoras viajan "juntas pero no revueltas". 
# 
# Este resultado es 칰til para la *demodulaci칩n coherente (en fase)* de se침ales IQ, porque permite "separar" una portadora de otra.
# 
# #### 3.3.2. - Modulaci칩n QPSK
# 
# La modulaci칩n BPSK tiene dos s칤mbolos posibles (`0`, `1`) lo que implica un bit $b$ por s칤mbolo, mientras que la modulaci칩n QPSK (*Quadrature Phase-Shift Keying*) tiene cuatro s칤mbolos posibles (`00`, `01`, `10`, `11`), con dos bits $b_1 b_2$ por s칤mbolo. La codificaci칩n para un s칤mbolo $b_1 b_2$ es ahora:
# 
# $$
# s(t) = A_1 \cos(2\pi f_c t) + A_2 \sin(2\pi f_c t)
# $$
# 
# donde
# 
# $$
# A_1 = 
# \begin{cases}
#              -1, &   \text{si} \quad b_1 = 0 \\
#              1, &  \text{si}   \quad b_1 = 1 \\
# \end{cases}
# $$
# 
# y
# 
# $$
# A_2 = 
# \begin{cases}
#              -1, &   \text{si} \quad b_2 = 0 \\
#               1, &   \text{si} \quad b_2 = 1 \\
# \end{cases}
# $$
# 
# <img src="https://www.analog.com/-/media/analog/en/landing-pages/technical-articles/low-power-iq-modulator-for-digital-communications/iqmodulator.png?h=270&hash=868F3CDB85D7842D27627F7A12099156E9729935&la=en" width="400">
# 
# Si se grafica la amplitud $A_1$ y $A_2$ de cada portadora en una gr치fica donde el eje $x$ representa al coseno (en fase, $I$) y el eje $y$ al seno (en cuadratura, $Q$), se obtiene lo que se conoce como un "diagrama de constelaci칩n" de la modulaci칩n:
# 
# <img src='https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/QPSK_Gray_Coded.svg/800px-QPSK_Gray_Coded.svg.png' width='200'>
# 
# Ah칤 es posible verificar la correspondencia de los bits $b_1 b_2$ (`00`, `01`, `10`, `11`) con los puntos de la constelaci칩n.
# 
# > La modulaci칩n QPSK es utilizada en el est치ndar Wi-Fi IEEE 802.11 (una de sus posibles modulaciones), en comunicaciones satelitales, y en 5G, entre otros.
# 
# #### 3.3.3. - Modulaci칩n 8-PSK
# 
# La modulaci칩n 8-PSK tiene ocho s칤mbolos posibles con tres bits $b_1 b_2 b_3$ por s칤mbolo. La codificaci칩n para un s칤mbolo $b_1 b_2 b_3$ es ahora:
# 
# $$
# s(t) = A_1 \cos(2\pi f_c t) + A_2 \sin(2\pi f_c t)
# $$
# 
# donde
# 
# $$
# \begin{cases}
#     A_1 = 1, & A_2 = 0 & \text{si} \quad b_1 b_2 b_3 = 111 \\
#     A_1 = h, & A_2 = h & \text{si} \quad b_1 b_2 b_3 = 110 \\
#     A_1 = 0, & A_2 = 1 & \text{si} \quad b_1 b_2 b_3 = 010 \\
#     A_1 =-h, & A_2 = h & \text{si} \quad b_1 b_2 b_3 = 011 \\
#     A_1 =-1, & A_2 = 0 & \text{si} \quad b_1 b_2 b_3 = 001 \\
#     A_1 =-h, & A_2 =-h & \text{si} \quad b_1 b_2 b_3 = 000 \\
#     A_1 = 0, & A_2 =-1 & \text{si} \quad b_1 b_2 b_3 = 100 \\
#     A_1 = h, & A_2 =-h & \text{si} \quad b_1 b_2 b_3 = 101 \\
# \end{cases}
# $$
# 
# donde $h = 1\sin(45^o) = 1\cos(45^o) = \sqrt{2}/2 \approx 0.707$.
# 
# El "diagrama de constelaci칩n" de la modulaci칩n es:
# 
# <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/8PSK_Gray_Coded.svg/400px-8PSK_Gray_Coded.svg.png" width="200">
# 
# Ah칤 es posible verificar la correspondencia de los bits $b_1 b_2 b_3$ (`000`, `001`, `010`, `011`, `100`, `101`, `110`, `111`) con los puntos de la constelaci칩n.
# 
# #### 3.3.4. - Modulaci칩n QAM
# 
# La modulaci칩n de amplitud en cuadratura (**QAM**, *Quadrature Amplitude Modulation*) es otro tipo de modulaci칩n IQ que ahora utiliza m치s posibles amplitudes de las dos portadoras para crear una constelaci칩n como la siguiente:
# 
# <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/16QAM_Gray_Coded.svg/1280px-16QAM_Gray_Coded.svg.png" width="250">
# 
# en donde se aprecian dos valores positivos y dos valores negativos para cada portadora. Este es el caso 16-QAM, en tanto que tiene 16 s칤mbolos de 4 bits cada uno ($2^4 = 16$).
# 
# La codificaci칩n para un s칤mbolo $b_1 b_2 b_3 b_4$ es:
# 
# $$
# s(t) = A_1 \cos(2\pi f_c t) + A_2 \sin(2\pi f_c t)
# $$
# 
# donde
# 
# $$
# A_1 = 
# \begin{cases}
#              -3, &   \text{si} \quad b_1 b_2 = 00 \\
#              -1, &   \text{si} \quad b_1 b_2 = 01 \\
#              1, &  \text{si}   \quad b_1 b_2 = 11 \\
#              3, &  \text{si}   \quad, b_1 b_2 = 10 \\
# \end{cases}
# $$
# 
# y
# 
# $$
# A_2 = 
# \begin{cases}
#              3, &   \text{si} \quad b_3 b_4 = 00 \\
#              1, &   \text{si} \quad b_3 b_4 = 01 \\
#              -1, &  \text{si}   \quad b_3 b_4 = 11 \\
#              -3, &  \text{si}   \quad b_3 b_4 = 10 \\
# \end{cases}
# $$
# 
# > La modulaci칩n QAM es tambi칠n utilizada en el est치ndar Wi-Fi IEEE 802.11 de forma adaptativa, por lo que puede ir desde 16-QAM (4 bits/s칤mbolo) hasta 512-QAM (9 bits/s칤mbolo) cuando las condiciones del canal son 칩ptimas.

# ---
# ## 4. - Asignaciones del proyecto
# 
# ### 4.1. - Modulaci칩n 8-PSK
# 
# * (50%) Realice una simulaci칩n del sistema de comunicaciones como en la secci칩n 3.2., pero utilizando una modulaci칩n **8-PSK** en lugar de una modulaci칩n BPSK. Deben mostrarse las im치genes enviadas y recuperadas y las formas de onda.
# 

# ## Soluci칩n parte 4.1. -Modulaci칩n 8-PSK

# Inicialmente se deben modificar las funciones:
# 
# __modulador(bits_Rx, FS, MPP)__: Convierte la se침al de informaci칩n (arreglo de bits_Tx) en una se침al
#     modulada bajo un esquema BPSK.
# 
# __demodulador(senal_Rx, carrier, MPP)__: Demodula a senal_Rx (se침al recibida) y determina los bits recibidos usando el 
#     criterio de demodulaci칩n por detecci칩n de energ칤a.
#     
#  Para considerar la modulaci칩n __8-PSK__, recordar que esta est치 dada por ocho s칤mbolos posibles con tres bits $b_1 b_2 b_3$ por s칤mbolo. La codificaci칩n para un s칤mbolo $b_1 b_2 b_3$ es ahora:
# 
# $$
# s(t) = A_1 \cos(2\pi f_c t) + A_2 \sin(2\pi f_c t)
# $$
# 
# donde
# 
# $$
# \begin{cases}
#     A_1 = 1, & A_2 = 0 & \text{si} \quad b_1 b_2 b_3 = 111 \\
#     A_1 = h, & A_2 = h & \text{si} \quad b_1 b_2 b_3 = 110 \\
#     A_1 = 0, & A_2 = 1 & \text{si} \quad b_1 b_2 b_3 = 010 \\
#     A_1 =-h, & A_2 = h & \text{si} \quad b_1 b_2 b_3 = 011 \\
#     A_1 =-1, & A_2 = 0 & \text{si} \quad b_1 b_2 b_3 = 001 \\
#     A_1 =-h, & A_2 =-h & \text{si} \quad b_1 b_2 b_3 = 000 \\
#     A_1 = 0, & A_2 =-1 & \text{si} \quad b_1 b_2 b_3 = 100 \\
#     A_1 = h, & A_2 =-h & \text{si} \quad b_1 b_2 b_3 = 101 \\
# \end{cases}
# $$
# 
# donde $h = 1\sin(45^o) = 1\cos(45^o) = \sqrt{2}/2 \approx 0.707$.

# ### Modulador 8-PSK

# In[16]:


import numpy as np


def modulador_8PSK(bits, fc, mpp):

    '''Un m칠todo que simula el esquema de
    modulaci칩n digital BPSK.

    :param bits: Vector unidimensional de bits
    :param fc: Frecuencia de la portadora en Hz
    :param mpp: Cantidad de muestras por periodo de onda portadora
    :return: Un vector con la se침al modulada
    :return: Un valor con la potencia promedio [W]
    :return: La onda portadora c(t)
    :return: La onda cuadrada moduladora (informaci칩n)
    '''
    # 1. Par치metros de la 'se침al' de informaci칩n (bits)
    N = len(bits)  # Cantidad de bits

    # 2. Construyendo un periodo de la se침al portadora c(t)
    Tc = 1 / fc  # periodo [s]
    t_periodo = np.linspace(0, Tc, mpp)  # mpp: muestras por per칤odo
    portadora = np.cos(2*np.pi*fc*t_periodo)
    # se debe agregar una segunda portadora
    portadora2 = np.sin(2*np.pi*fc*t_periodo)

    # 3. Inicializar la se침al modulada s(t)
    t_simulacion = np.linspace(0, N*Tc, N*mpp)
    senal_Tx = np.zeros(t_simulacion.shape)
    moduladora = np.zeros(t_simulacion.shape)  # (opcional) se침al de bits

    # Se define el valor de h
    h = np.sqrt(2)/2

    # 4. Asignar las formas de onda seg칰n los bits (8-PSK)
    for i in range(0, N, 3):

        # 洧녪1洧녪2洧녪3=111 A_1 = 1, & A_2 = 0
        if bits[i] == 1 and bits[i+1] == 1 and bits[i+2] == 1:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora * 1 + portadora2 * 0

        # 洧녪1洧녪2洧녪3=110 A_1 = h, & A_2 = h
        elif bits[i] == 1 and bits[i+1] == 1 and bits[i+2] == 0:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora * h + portadora2 * h

        # 洧녪1洧녪2洧녪3=010  A_1 = 0, & A_2 = 1
        elif bits[i] == 0 and bits[i+1] == 1 and bits[i+2] == 0:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora * 0 + portadora2 * 1

        # 洧녪1洧녪2洧녪3=011 A_1 =-h, & A_2 = h
        elif bits[i] == 0 and bits[i+1] == 1 and bits[i+2] == 1:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora * -h + portadora2 * h

        # 洧녪1洧녪2洧녪3=001 A_1 =-h, & A_2 = h
        elif bits[i] == 0 and bits[i+1] == 0 and bits[i+2] == 1:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora * -1 + portadora2 * 0

        # 洧녪1洧녪2洧녪3=000 A_1 =-h, & A_2 =-h
        elif bits[i] == 0 and bits[i+1] == 0 and bits[i+2] == 0:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora * -h + portadora2 * -h

        # 洧녪1洧녪2洧녪3=100 A_1 = 0, & A_2 =-1
        elif bits[i] == 1 and bits[i+1] == 0 and bits[i+2] == 0:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora * 0 + portadora2 * -1

    # 洧녪1洧녪2洧녪3=101 A_1 = h, & A_2 =-h
        elif bits[i] == 1 and bits[i+1] == 0 and bits[i+2] == 1:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora * h + portadora2 * -h

    # 5. Calcular la potencia promedio de la se침al modulada
    P_senal_Tx = (1 / (N*Tc)) * np.trapz(pow(senal_Tx, 2), t_simulacion)

    return senal_Tx, P_senal_Tx, portadora, portadora2, moduladora


# ### Demodulador

# In[17]:


import numpy as np

def demodulador_8PSK(senal_Rx, portadora, portadora2, mpp):
    '''Un m칠todo que simula un bloque demodulador
    de se침ales, bajo un esquema BPSK. El criterio
    de demodulaci칩n se basa en decodificaci칩n por 
    detecci칩n de energ칤a.

    :param senal_Rx: La se침al recibida del canal
    :param portadora: La onda portadora c(t)
    :param mpp: N칰mero de muestras por periodo
    :return: Los bits de la se침al demodulada
    '''
    # Cantidad de muestras en senal_Rx
    M = len(senal_Rx)

    # Cantidad de bits (s칤mbolos) en transmisi칩n
    N = int(M / mpp)

    # Vector para bits obtenidos por la demodulaci칩n
    bits_Rx = np.zeros(N)

    # Vector para la se침al demodulada
    senal_demodulada = np.zeros(senal_Rx.shape)

    # Pseudo-energ칤a de un per칤odo de la primera portadora
    Es = np.sum(portadora * portadora)
    
     # Pseudo-energ칤a de un per칤odo de la segunda portadora
    Es2 = np.sum(portadora2 * portadora2)

    # Demodulaci칩n
    for i in range(N):
        # Producto interno de dos funciones
        producto = senal_Rx[i*mpp : (i+1)*mpp] * portadora
        Ep = np.sum(producto) 
        
        # se repite el procedimiento, ahora para la portadora 2
        producto2 = senal_Rx[i*mpp : (i+1)*mpp] * portadora2
        Ep2 = np.sum(producto2)
        
        # se obtiene la se침al demulada como la suma de ambos 
        # productos internos de las funciones 
        
        senal_demodulada[i*mpp : (i+1)*mpp] = producto + producto2

        # Criterio de decisi칩n por detecci칩n de energ칤a
        
        # valor h:
        h = np.sqrt(2)/2
        
        ''' 
            Se deben tomar en cuenta los umbrales en los cuales 
            se encuentra la energ칤a 
            -(1+h)/2 > E ---- -1
            -h/2  > E > -(1+h)/2 ---- -h
            h/2 > E > -h/2 ----- 0
            (1+h)/2 > E > h/2 ---- h 
            E> (1+h)/2 -----1
            
                A_1 = 1, & A_2 = 0 &   b_1 b_2 b_3 = 111 \\
                A_1 = h, & A_2 = h &   b_1 b_2 b_3 = 110 \\
                A_1 = 0, & A_2 = 1 &   b_1 b_2 b_3 = 010 \\
                A_1 =-h, & A_2 = h &   b_1 b_2 b_3 = 011 \\
                A_1 =-1, & A_2 = 0 &   b_1 b_2 b_3 = 001 \\
                A_1 =-h, & A_2 =-h &   b_1 b_2 b_3 = 000 \\
                A_1 = 0, & A_2 =-1 &   b_1 b_2 b_3 = 100 \\
                A_1 = h, & A_2 =-h &   b_1 b_2 b_3 = 101 \\
        '''
        
        if i % 3 == 0:
            if Ep >= ((1+h)/2)*Es and (h/2)*Es2 >= Ep2 and Ep2 >= (-h/2)*Es2:
                bits_Rx[i] = 1
                bits_Rx[i+1] = 1
                bits_Rx[i+2] = 1
            
            elif Ep <= ((1+h)/2)*Es and Ep >= (h/2)*Es and Ep2 <= ((1+h)/2)*Es2 and Ep2 >= (h/2)*Es2:
                bits_Rx[i] = 1
                bits_Rx[i+1] = 1
                bits_Rx[i+2] = 0
            
            elif (h/2)*Es >= Ep and  Ep >= (-h/2)*Es and Ep2>= ((1+h)/2)*Es2 :
                bits_Rx[i] = 0
                bits_Rx[i+1] = 1
                bits_Rx[i+2] = 0
                
            elif (-h/2)*Es  >= Ep and Ep >= (-(1+h)/2)*Es and Ep2 <= ((1+h)/2)*Es2 and Ep2 >= (h/2)*Es2:
                bits_Rx[i] = 0
                bits_Rx[i+1] = 1
                bits_Rx[i+2] = 1
                
            elif (-(1+h)/2)*Es >= Ep and (h/2)*Es2 >= Ep2 and Ep2 >= (-h/2)*Es2 :
                bits_Rx[i] = 0
                bits_Rx[i+1] = 0
                bits_Rx[i+2] = 1
                
            elif (-h/2)*Es >= Ep and Ep >= (-(1+h)/2)*Es and (-h/2)*Es2 >= Ep2 and Ep2>= (-(1+h)/2)*Es2:
                bits_Rx[i] = 0
                bits_Rx[i+1] = 0
                bits_Rx[i+2] = 0
                
            elif  (h/2)*Es >= Ep and Ep >= (-h/2)*Es and (-(1+h)/2)*Es2 >= Ep2 :
                bits_Rx[i] = 1
                bits_Rx[i+1] = 0
                bits_Rx[i+2] = 0
                
            elif ((1+h)/2)*Es >= Ep and Ep >= (h/2)*Es and (-h/2)*Es2 >= Ep2 and Ep2 >=(-(1+h)/2)*Es2:
                bits_Rx[i] = 1
                bits_Rx[i+1] = 0
                bits_Rx[i+2] = 1


    return bits_Rx.astype(int), senal_demodulada


# Se procede a realizar la simulaci칩n del sistema de comunicaciones como en la secci칩n 3.2., pero ahora utilizando la modulaci칩n 8-PSK en lugar de una modulaci칩n BPSK, para esto se utilizar치n las funciones "moduladora", "canal ruidoso" modificadas anteriormente bajo las condiciones de la modulaci칩n 8-PSK.

# In[19]:


import numpy as np
import matplotlib.pyplot as plt
import time

# Par치metros
fc = 5000  # frecuencia de la portadora
mpp = 20   # muestras por periodo de la portadora
SNR = 10  # relaci칩n se침al-a-ruido del canal

# Iniciar medici칩n del tiempo de simulaci칩n
inicio = time.time()

# 1. Importar y convertir la imagen a trasmitir
imagen_Tx = fuente_info('arenal.jpg')
dimensiones = imagen_Tx.shape

# 2. Codificar los pixeles de la imagen
bits_Tx = rgb_a_bit(imagen_Tx)

# 3. Modular la cadena de bits usando el esquema BPSK
senal_Tx, P_senal_Tx, portadora, portadora2, moduladora = modulador_8PSK(bits_Tx, fc, mpp)

# 4. Se transmite la se침al modulada, por un canal ruidoso
senal_Rx = canal_ruidoso(senal_Tx, P_senal_Tx, SNR)

# 5. Se desmodula la se침al recibida del canal
bits_Rx, senal_demodulada = demodulador_8PSK(senal_Rx, portadora,portadora2, mpp)

# 6. Se visualiza la imagen recibida
imagen_Rx = bits_a_rgb(bits_Rx, dimensiones)
Fig = plt.figure(figsize=(10, 6))

# C치lculo del tiempo de simulaci칩n
print('Duraci칩n de la simulaci칩n: ', time.time() - inicio)

# 7. Calcular n칰mero de errores
errores = sum(abs(bits_Tx - bits_Rx))
BER = errores/len(bits_Tx)
print('{} errores, para un BER de {:0.4f}.'.format(errores, BER))

# Mostrar imagen transmitida
ax = Fig.add_subplot(1, 2, 1)
imgplot = plt.imshow(imagen_Tx)
ax.set_title('Transmitido')

# Mostrar imagen recuperada
ax = Fig.add_subplot(1, 2, 2)
imgplot = plt.imshow(imagen_Rx)
ax.set_title('Recuperado')
Fig.tight_layout()

plt.imshow(imagen_Rx)


# La imagen recuperada anteriormente se hizo tomando en consideraci칩n un SNR = 10, recordar que el SNR corresponde a la
# relaci칩n se침al-a-ruido del canal. Por indicaciones del profesor se consider칩 que este par치metro no sobrepase un valor de 20,
# sin embargo, se dej칩 en 10 ya que para este punto la imagen es lo suficientemente buena y clara con unos 46 errores. 
# Es importante considerar que se comprob칩 para distintos valores de SNR donde para un SNR de 0 los errores 
# presentados son de poco m치s de 40 mil errores
# y en contraparte para un NSR= 7 los
# errores son unos  1900.

# In[20]:


import matplotlib.pyplot as plt

# Visualizar el cambio entre las se침ales
fig, (ax1, ax2, ax3) = plt.subplots(nrows=3, sharex=True, figsize=(14, 7))

# La se침al modulada con el m칠todo 8PSK
ax1.plot(senal_Tx[0:600], color='r', lw=2)
ax1.set_ylabel('$s(t)$')

# La se침al modulada al dejar el canal
ax2.plot(senal_Rx[0:600], color='g', lw=2)
ax2.set_ylabel('$s(t)  + n(t)$')

# La se침al modulada al dejar el canal
ax3.plot(senal_demodulada[0:600], color='b', lw=2)
ax3.set_ylabel('$b^{\prime}(t)$')
ax3.set_xlabel('$t$/ milisegundos')

fig.tight_layout()
plt.show()


# En la figura anterior se detalla el comportamiento de las se침ales en orden descendente:
# 
# __La se침al (Tx):__ corresponde a la se침al modulada $s(t)$
# 
# __La se침al (Rx):__ corresponde a la se침al recibida $s(t) + n(t)$
# 
# __La se침al demodulada:__ corresponde a la se침al demodulada $b^{\prime}(t)$

# ### 4.2. - Estacionaridad y ergodicidad
# 
# * (30%) Realice pruebas de estacionaridad y ergodicidad a la se침al modulada `senal_Tx` y obtenga conclusiones sobre estas.
# 
# 

# In[13]:


# Se definen los tiempos
T = 100
t_final = 0.1
t = np.linspace(0, t_final, T)
# Se definen las listas con los pares de variables aleatorias
h = np.sqrt(2) / 2
A1 = [1, h, 0, -h, -1, -h, 0, h]
A2 = [0, h, 1, h, 0, -h, -1, -h]
# Hay 8 posibilidades de la onda por el m칩dulo utilizado
N = 8

# Se coloca una matriz con N filas y T columnas que ser치n las muestras
Todo = np.empty((N, len(t)))

# Se crea un ciclo que genere los senos y
# cosenos con sus amplitudes respectivas por bit
for i in range(len(A1)):
    # Se colocaron en las listas los valores por posici칩n seg칰n los bits.
    # La funci칩n generar치 muestras por cada par de amplitudes.
    A = A1[i]*np.cos(2*np.pi*fc*t) + A2[i]*np.sin(2*np.pi*fc*t)
    # La
    Todo[i, :] = A
    plt.plot(t, A)

# Promedio de las N realizaciones en cada instante (cada punto en t)
Prom = [np.mean(Todo[:, i]) for i in range(len(t))]
Muestras = plt.plot(t, Prom, lw=6, color='r', label='Promedio muestras')

# Valor te칩rico
ValE = np.mean(senal_Tx)*t
Teorico = plt.plot(t, ValE, '--', lw=3, color='k', label='Valor teorico')

# Gr치fica para los valores teoricos y las muestras
plt.title('Muestras del proceso $X(t)$')
plt.xlabel('t')
plt.ylabel('$x_i(t)$')
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
plt.show()


# Recordar que la ergodicidad establece la igualdad entre el promedio estad칤stico y el promedio temporal de un proceso aleatorio.
# Los A[1] se utilizan para denotar el promedio temporal y de una manera an치loga se utiliza el operador E para el promedio estad칤stico. De modo que con la gr치fica anterior se logra representar el comportamiento entre estos, tal como se obtuvo el promedio de las muestras y el promedio te칩rico est치n cercano a cero y son constantes cumpliendo as칤 la estacionaridad.
# Ahora bien en terminos de la ergodicidad se sabe que un proceso es erg칩dico si sus promedios estad칤sticos se ajustan con
# los respectivos promedios temporales, en este caso como se observa en la gr치fica  el promedio de realizaciones (promedio estad칤stico) es igual al resultado te칩rico (promedio temporal), es decir se ajusta a 칠l, por lo tanto el proceso anterior es erg칩dico. 
# 
# En conclusion el proceso anterior se considera estacionario y erg칩dico.

# ### 4.3. - Densidad espectral de potencia
# 
# * (20%) Determine y grafique la densidad espectral de potencia para la se침al modulada `senal_Tx`.
# 
# \begin{equation}
# \displaystyle
# \mathcal{S}_{XX}(\omega) = \lim_{T \rightarrow \infty}\frac{E[\vert X_{T}(\omega) \vert^2]}{2T}
# \end{equation}

# In[26]:


from scipy.fft import fft

# Transformada de Fourier
senal_f = fft(senal_Tx)

# Muestras de la se침al
Nm = len(senal_Tx)

# N칰mero de s칤mbolos (198 x 89 x 8 x 3)
Ns = Nm // mpp

# Tiempo del s칤mbolo = periodo de la onda portadora
Tc = 1 / fc

# Tiempo entre muestras (per칤odo de muestreo)
Tm = Tc / mpp

# Tiempo de la simulaci칩n
T = Ns * Tc

# Espacio de frecuencias
f = np.linspace(0.0, 1.0/(2.0*Tm), Nm//2)

# Gr치fica
plt.plot(f, 2.0/Nm * np.power(np.abs(senal_f[0:Nm//2]), 2))
plt.xlim(0, 20000)
plt.grid()
plt.show()


# ---
# 
# ### Universidad de Costa Rica
# #### Facultad de Ingenier칤a
# ##### Escuela de Ingenier칤a El칠ctrica
# 
# ---
